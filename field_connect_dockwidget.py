# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FieldConnectDockWidget
                                 A QGIS plugin
 Connects to Field Desktop
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-18
        git sha              : $Format:%H$
        copyright            : (C) 2025 by VZG
        email                : oliver.zapiec@gbv.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, json, csv, io, re
from requests.models import Response
from urllib.parse import urlparse, urlunparse, ParseResult
from collections import defaultdict

from qgis.core import Qgis, QgsApplication, QgsProject, QgsVectorLayer, QgsCoordinateReferenceSystem, \
QgsFields, QgsField, QgsGeometry, QgsJsonUtils, QgsFeature, QgsVectorFileWriter, QgsWkbTypes, \
QgsJsonExporter, QgsEditorWidgetSetup, QgsSettings, QgsDefaultValue, \
QgsExpressionContextUtils, QgsMapLayer, QgsLayerTreeGroup, NULL
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import Qt, QVariant, pyqtSignal
from qgis.gui import QgsMessageBar
from qgis.utils import iface
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QStatusBar, QSizePolicy, QGraphicsDropShadowEffect, \
QMessageBox, QFormLayout, QLabel, QFileDialog

from .modules.api_client import ApiClient
from .utils.constants import GEOJSON_TO_QGIS
from .utils.helpers import *
from .resources import *


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'field_connect_dockwidget_base.ui'))


class FieldConnectDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    def __init__(self, plugin_dir, parent=None):
        """Constructor."""
        super(FieldConnectDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # hide server address input in ui for now
        self.labelServerAddress.hide()
        self.lineEditServerAddress.hide()

        self.plugin_name = 'Field Connect'
        self.plugin_dir = plugin_dir
        self.project = QgsProject.instance()
        self.treeRoot = self.project.layerTreeRoot()
        self.projectConfig = {}  # /configuration/{project} :3000, not /{project}/configuration :3001
        self.projectConfigCategories = {}

        # show field information after connecting
        self.fieldUser = ''
        self.fieldVersion = ''
        self.activeProject = ''

        self.connected = False

        # weblate/linguist translation labels - extraction with pylupdate5 field_connect.pro
        self.labels = {
            'BAD_REQUEST': self.tr('Bad request'),
            'CONNECTION_LOST': self.tr('Connection lost!'),
            'CONNECTION_UNAUTHORIZED': self.tr('Unauthorized'),
            'DESELECT_ALL': self.tr('Deselect all'),
            'FIELD_CONNECTED': self.tr('Connected to Field Desktop'),
            'IMPORT_FAILED': self.tr('Import failed!'),
            'IMPORT_SUCCESS': self.tr('Import successful!'),
            'LAYER_VALIDATION_FAILED': self.tr('Layer validation failed!'),
            'CAT_NAME_EXTRACTION_FAILED': self.tr('Could not extract category name. Please set the layer variable "field_category" manually'),
            'NO_CATS_FOUND': self.tr('No categories found'),
            'REQUEST_FAILED': self.tr('Request failed'),
            'SELECT_ALL': self.tr('Select all'),
            'INFO_NO_LAYER_SELECTED': self.tr('No layer selected in the layer tree!')
        }

        # manual attribute translations
        self.trAttrs = {
            'identifier': {'label': self.tr('Identifier'), 'description': self.tr('The unique identifier of the resource')},
            'date': {
                'value': {'label': self.tr('Value'), 'description': self.tr('The date specification for a single date; the start date for a date range')},
                'endValue': {'label': self.tr('End value'), 'description': self.tr('The end date for a date range')},
                'isRange': {'label': self.tr('Is range?'), 'description': self.tr('Indicates whether the date is a date range. Possible values are: true (date range), false (single date).')}
            },
            'relations': {
                'label': self.tr('Relation'),
                'isChildOf': {'label': self.tr('Is child of'), 'description': self.tr('Specifies the direct parent resource in the hierarchy; remains empty for top-level resources.')},
                'isRecordedIn': {'label': self.tr('Is recorded in'), 'description': self.tr('Specifies the operation in which the resource has been recorded; remains empty for top-level resources.')},
                'liesWithin': {'label': self.tr('Lies within'), 'description': self.tr('Specifies the direct parent resource in the hierarchy; remains empty for top-level resources or if the direct parent resource is an operation.')},
                'depicts': {'label': self.tr('Depicts'), 'description': self.tr('Links the image to one or more resources')},
                'isDepictedIn': {'label': self.tr('Is depicted in'), 'description': self.tr('Links the resource to one or more images.')},
                'isMapLayerOf': {'label': self.tr('Is map layer of'), 'description': self.tr('Adds the image as a map layer in the context of the resource specified as the target.')},
                'hasMapLayer': {'label': self.tr('Has map layer'), 'description': self.tr('Adds one or more images as a map layer in the context of this resource.')},
                'hasDefaultMapLayer': {'label': self.tr('Has default map layer'), 'description': self.tr('Specifies that the linked image is a default map layer in the context of this resource.')}
            },
            'dating': {
                'type': {'label': self.tr('Type'), 'description': self.tr('The dating type. Possible values are: range (Period), single (Single year), before (Before), after (After), scientific (Scientific).')},
                'begin': {
                    'label': self.tr('Beginning:'),
                    'description': self.tr('Year specification that is set for the dating type "after" and as the start date for the dating type "range".'),
                    'inputType': {'label': self.tr('Dating system'), 'description': self.tr('The time scale. Possible values are: bce (BCE), ce (CE), bp (BP).')},
                    'inputYear': {'label': self.tr('Year'), 'description': self.tr('The year.')}
                },
                'end': {'label': self.tr('End:'), 'description': self.tr('Year specification that is set for the dating types "single", "before" and "scientific" and as the end date for the dating type "range".'),},
                'margin': {'label': self.tr('Margin'), 'description': self.tr('Tolerance margin in years for dating type "scientific".')},
                'source': {'label': self.tr('Source'), 'description': self.tr('Source of the dating.')},
                'isImprecise': {'label': self.tr('Is imprecise?'), 'description': self.tr('Specification "Imprecise". Cannot be set for dating type "scientific". Possible values are: true (yes), false (no).')},
                'isUncertain': {'label': self.tr('Is uncertain?'), 'description': self.tr('Specification "Uncertain". Cannot be set for dating type "scientific". Possible values are: true (yes), false (no).')},
            },
            'measurement': {
                'inputValue': {'label': self.tr('Value'), 'description': self.tr('The measured numerical value.')},
                'inputRangeEndValue': {'label': self.tr('End value'), 'description': self.tr('The second measured numerical value, if the dimension is a range.')},
                'measurementComment': {'label': self.tr('Comment')},
                'isImprecise': {'label': self.tr('Is imprecise?'), 'description': self.tr('Specification "Imprecise". Possible values are: true (yes), false (no).')},
            },
            'dimension': {
                'measurementPosition': {'label': self.tr('As measured by')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: mm, cm, m.')}
            },
            'weight': {
                'measurementDevice': {'label': self.tr('Measurement device')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: mg, g, kg.')}
            },
            'volume': {
                'measurementTechnique': {'label': self.tr('Measurement technique')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: ml, l.')}
            },
            'literature': {
                'quotation': {'label': self.tr('Literature quotation')},
                'zenonId': {'label': self.tr('Zenon ID')},
                'doi': {'label': self.tr('DOI')},
                'page': {'label': self.tr('Page')},
                'figure': {'label': self.tr('Figure')}
            },
            'period': {
                'label': self.tr('Period'),
                'value': {'label': self.tr('Value'), 'description': self.tr('The identifier of the selected value; if two values are selected, the first of the two values.')},
                'endValue': {'label': self.tr('End value'), 'description': self.tr('The identifier of the second selected value if two values are selected.')}
            },
            "de": {'label': self.tr('German')},
            "en": {'label': self.tr('English')},
            "es": {'label': self.tr('Spanish')},
            "fr": {'label': self.tr('French')},
            "it": {'label': self.tr('Italian')},
            "pt": {'label': self.tr('Portuguese')},
            "tr": {'label': self.tr('Turkish')},
            "uk": {'label': self.tr('Ukrainian')}
        }
        # link identical translations
        self.trAttrs['dating']['end']['inputType'] = self.trAttrs['dating']['begin']['inputType']
        self.trAttrs['dating']['end']['inputYear'] = self.trAttrs['dating']['begin']['inputYear']
        self.trAttrs['dimension']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['dimension']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['dimension']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['dimension']['isImprecise'] = self.trAttrs['measurement']['isImprecise']
        self.trAttrs['weight']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['weight']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['weight']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['weight']['isImprecise'] = self.trAttrs['measurement']['isImprecise']
        self.trAttrs['volume']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['volume']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['volume']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['volume']['isImprecise'] = self.trAttrs['measurement']['isImprecise']

        # layout
        self.toggleFieldInfo()
        self.selectImportCrs.setCrs(self.project.crs())
        self.selectExportCrs.setCrs(self.project.crs())
        self.formLayout.setWidget(self.formLayout.getWidgetPosition(self.hzLineSettings)[0], QFormLayout.SpanningRole, self.hzLineSettings)
        # add fullwidth for category selection
        # self.formLayout.setWidget(self.formLayout.getWidgetPosition(self.selectCats)[0], QFormLayout.SpanningRole, self.selectCats)
        self.setConnectionStatus()
        self.mB: QgsMessageBar = iface.messageBar()
        self.sB = QStatusBar()
        self.sB.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        self.sB.showMessage(self.tr("Ready to connect"))
        self.dockWidgetContents.layout().addWidget(self.sB)
        self.selectCats.view().setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        # export tab
        self.exportUpdateLayerGroups()
        # load saved settings
        self.loadSettings()

        # connections
        self.btnConnect.clicked.connect(self.fieldConnect)
        self.btnImport.clicked.connect(self.fieldImport)
        self.btnExport.clicked.connect(self.fieldExport)
        self.selectCats.model().itemChanged.connect(self.handleCats)
        # export
        self.treeRoot.addedChildren.connect(self.exportUpdateLayerGroups)
        self.treeRoot.removedChildren.connect(self.exportUpdateLayerGroups)
        self.treeRoot.nameChanged.connect(self.exportUpdateLayerGroups)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def exportUpdateLayerGroups(self):
        self.selectExGroup.clear()
        gs = self.treeRoot.findGroups()
        [self.selectExGroup.addItem(group.name(), group) for group in gs] if gs else self.selectExGroup.addItem(self.tr('No groups available'))

    def setProjectCrs(self):
        """Sets the project crs when connecting to Field Desktop if available,
        or uses the one set in the QGIS Project"""
        epsgId = safe_get(self.api.get(f'/{self.activeProject}/project', port=3001).json(), 'resource', 'epsgId')
        crs = QgsCoordinateReferenceSystem(epsgId)

        if crs.isValid():
            self.project.setCrs(crs)
            self.selectImportCrs.setCrs(crs)
            self.selectExportCrs.setCrs(crs)
        else:
            projectCrs = self.project.crs()
            self.selectExportCrs.setCrs(projectCrs)
            self.selectExportCrs.setCrs(projectCrs)
            self.selectExportCrs.setCrs(projectCrs)
            self.mB.pushWarning(self.plugin_name, self.tr(f'Invalid EPSG Code in Field Desktop: {epsgId}. Using QGIS project CRS.'))

    def normalize_export_value(self, value):
        """Normalize attribute values for CSV export.
        Converts QGIS multiselect formats {a,b,c} ‚Üí a;b;c, stripping any quotes."""

        if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
            inner = value[1:-1].strip()
            if inner:
                # remove any existing double quotes and split by comma
                parts = [p.strip().replace('"', '') for p in inner.split(',') if p.strip()]
                return ';'.join(parts)
            else:
                return ''

        return value

    def toggleFieldInfo(self, user='', version=''):
        """Show user and version when connected, hide if not"""
        d = {self.labelFieldUser:user, self.labelFieldVersion:version}
        for k,v in d.items():
            row = self.formLayout.getWidgetPosition(k)[0]
            w = self.formLayout.itemAt(row, QFormLayout.FieldRole)
            if w:
                self.formLayout.removeWidget(w.widget())
            # k.setVisible(not k.isVisible())
            policy = k.sizePolicy()
            # only hide if disconnected
            if policy.horizontalPolicy() == QSizePolicy.Preferred and not self.connected:
                k.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
            elif self.connected:
                label = QLabel(v)
                self.formLayout.setWidget(row, QFormLayout.FieldRole, label)
                k.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

    # self.activeProject gets set when pressing the connect button and status == 200
    # currently unused as only the activeProject is selectable
    def isActiveProject(self, project):
        if self.activeProject != project:
            self.mB.pushMessage(': '.join([self.plugin_name, self.tr('Only the currently active project in Field Desktop can be imported!')]), Qgis.Warning, 5)

    # for de-/selecting items in the category field
    def handleCats(self, item):
        self.selectCats.model().blockSignals(True)
        row = self.selectCats.model().indexFromItem(item).row()
        # print(row)
        if row == 0:  # first de-/select all entry
            state = item.checkState()
            for i in range(1, self.selectCats.count()):
                self.selectCats.model().item(i).setCheckState(state)
            item.setText(self.labels['DESELECT_ALL'] if state == Qt.Checked else self.labels['SELECT_ALL'])
        else:
            # update the first item to reflect whether all other items are checked
            all_checked = all(self.selectCats.model().item(i).checkState() == Qt.Checked for i in range(1, self.selectCats.count()))
            self.selectCats.model().item(0).setCheckState(Qt.Checked if all_checked else Qt.Unchecked)
            self.selectCats.model().item(0).setText(self.labels['DESELECT_ALL'] if all_checked else self.labels['SELECT_ALL'])
        self.selectCats.model().blockSignals(False)

    def createLookupLayerTemp(self):
        """Create a temporary lookup layer for value relations for the Field Desktop input type 'checkboxes'"""
        fields = QgsFields()
        # fields.append(QgsField('id', QVariant.Int))
        fields.append(QgsField('group_id', QVariant.String))
        fields.append(QgsField('key', QVariant.String))
        fields.append(QgsField('value', QVariant.String))
        fields.append(QgsField('description', QVariant.String))

        lupLayer = QgsVectorLayer(
            'None',   # no geometry
            f'{self.activeProject}_lookup',
            "memory"
        )

        pr = lupLayer.dataProvider()
        pr.addAttributes(fields)
        lupLayer.updateFields()

        return lupLayer

    # dataSourceUri: .gpkg|layername=.*_CategoryName'
    def getCategoryNameForExport(self, layer: QgsVectorLayer):
        """Extract the category name from the layer variable 'field_category' which is set on import, or
        try the dataSourceUri as fallback"""
        catName = QgsExpressionContextUtils.layerScope(layer).variable('field_category') or layer.dataProvider().dataSourceUri().split('_')[-1] or ''

        return catName

    def loadImportCategories(self):
        """Loads available categories for import with translated labels
        and their original name as userData."""
        lang = QgsApplication.locale()
        self.selectCats.clear()
        cats = []

        def collect_categories(node):
            """
            Recursively collect categories from nested dict/list structures.
            """
            if not isinstance(node, dict): return

            item = node.get("item")
            if isinstance(item, dict) and "name" in item:
                uLabel = item["name"]
                tLabel = safe_get(item, "label", lang)
                cats.append((tLabel or uLabel, uLabel))

            # Recurse into subtrees
            trees = node.get("trees")
            if isinstance(trees, list):
                for sub in trees:
                    collect_categories(sub)

        categories = self.projectConfig.get("categories")
        if isinstance(categories, dict):
            collect_categories(categories)
        elif isinstance(categories, list):
            for cat in categories:
                collect_categories(cat)

        if cats:
            self.selectCats.addItem(self.labels['SELECT_ALL'])
            for label, name in cats:
                self.selectCats.addItem(label, name)
        else:
            self.selectCats.model().blockSignals(True)
            self.selectCats.clear()
            self.selectCats.addItem(self.labels['NO_CATS_FOUND'])
            self.selectCats.setCurrentIndex(0)
            self.selectCats.setItemCheckState(0, Qt.Checked)
            self.selectCats.setEnabled(False)
            self.selectCats.model().blockSignals(False)
            return
        self.selectCats.setEnabled(True)

    # todo: change method name as it does more than get translations now
    def getCsvHeaderTranslations(self, cat):  # üê±
        """Get translations from the project config.
        Ignores the category field as it is not getting exported in a CSV export.
        Moves relation fields into a nested 'relations' dict.
        Moves composite fields into nested dicts keyed by their 'name'.
        Also collects value maps from valuelist properties for later assignment."""

        lang = QgsApplication.locale()
        translations = {'relations': {}}
        valuemaps = {}

        def recurse(data, result, seen=None, path='root'):
            """Recursively collect field translations for the given locale."""
            if seen is None:
                seen = set()

            if isinstance(data, dict):
                if 'name' in data and isinstance(data['name'], str):
                    fieldname = data['name']
                    inputType = data.get('inputType', '')
                    if fieldname != 'category':
                        if fieldname in seen:
                            print(f'Duplicate field "{fieldname}" found at {path}')
                        seen.add(fieldname)

                        # try to get translated label for the current locale
                        label = data.get('label', {}).get(lang, fieldname)
                        description = data.get('description', {}).get(lang, '')
                        if not description:
                            description = data.get('description', {}).get('en', '')

                        if 'valuelist' in data:
                            vmap = {}
                            values = data['valuelist'].get('values', {})
                            for key, vdef in values.items():
                                vlabel = vdef.get('label', {}).get(lang, key)
                                vmap[vlabel] = key  # vmaps need the format description:value, although the gui says value:description
                            if vmap:
                                valuemaps[fieldname] = {'map': vmap, 'type': inputType}

                        # handle relation fields
                        if data.get('inputType') == 'relation':
                            result.setdefault('relations', {})[fieldname] = {
                                'label': label,
                                'description': description,
                            }

                        # handle composite fields
                        elif data.get('inputType') == 'composite':
                            comp = result.setdefault(fieldname, {
                                'label': label,
                                'description': description,
                            })
                            # collect subfields as nested entries
                            subfields = data.get('subfields', [])
                            if isinstance(subfields, list):
                                for sf in subfields:
                                    sf_name = sf.get('name')
                                    if not sf_name:
                                        continue
                                    sf_label = sf.get('label', {}).get(lang, sf_name)
                                    sf_descr = sf.get('description', {}).get(lang, '')
                                    if not sf_descr:
                                        sf_descr = sf.get('description', {}).get('en', '')
                                    comp[sf_name] = {
                                        'label': sf_label,
                                        'description': sf_descr,
                                    }

                                    if 'valuelist' in sf:
                                        vmap = {}
                                        values = sf['valuelist'].get('values', {})
                                        for key, vdef in values.items():
                                            vlabel = vdef.get('label', {}).get(lang, key)
                                            vmap[vlabel] = key
                                        if vmap:
                                            valuemaps[sf_name] = {'map': vmap}

                            data = {k: v for k, v in data.items() if k != 'subfields'}
                        # regular fields
                        else:
                            result[fieldname] = {
                                'label': label,
                                'description': description,
                            }

                # recurse into nested structures
                for k, v in data.items():
                    recurse(v, result, seen, f'{path}.{k}')

            elif isinstance(data, list):
                for i, item in enumerate(data):
                    recurse(item, result, seen, f'{path}[{i}]')

            return result

        fCat = None
        for d in safe_get(self.projectConfig, 'categories', default=[]):
            # check top-level category name
            if safe_get(d, 'item', 'name') == cat:
                fCat = d
                break

            # check nested trees within category
            for t in safe_get(d, 'trees', default=[]):
                if safe_get(t, 'item', 'name') == cat:
                    fCat = t
                    break
            if fCat:
                break

        if fCat:
            # recurse through the category to find all field definitions
            fGroups = safe_get(fCat, 'item', 'groups')
            if fGroups:
                for group in fGroups:
                    recurse(group, translations)
            fTrees = safe_get(fCat, 'item')
            if fTrees:
                for group in fTrees:
                    recurse(group, translations)

        return translations, valuemaps

    def saveSettings(self):
        """
        Save user settings made in the ui
        """
        pn = self.plugin_name.replace(' ', '').lower()
        s = QgsSettings()
        # import tab
        s.setValue(f'{pn}/import/format', self.radioFormatMemory.objectName() if self.radioFormatMemory.isChecked() else self.radioFormatGPKG.objectName())
        s.setValue(f'{pn}/import/setalias', self.chkSetAliases.isChecked())
        s.setValue(f'{pn}/import/combineHierarchicalRelations', self.chkCombineRel.isChecked())
        # export tab
        s.setValue(f'{pn}/export/mode', self.radioExGroup.objectName() if self.radioExGroup.isChecked() else self.radioExActiveLayer.objectName())
        s.setValue(f'{pn}/export/permitDeletions', self.chkPermitDel.isChecked())
        s.setValue(f'{pn}/export/ignoreUnconfiguredFields', self.chkIgnoreUnconfFields.isChecked())

    def loadSettings(self):
        """
        Load user settings made in the ui
        """
        pn = self.plugin_name.replace(' ', '').lower()
        s = QgsSettings()
        # import tab
        rbName = s.value(f'{pn}/import/format', 'radioFormatMemory')
        next(rb.setChecked(True) for rb in (self.radioFormatMemory, self.radioFormatGPKG) if rb.objectName() == rbName)
        self.chkSetAliases.setChecked(s.value(f'{pn}/import/setalias', True, bool))
        self.chkCombineRel.setChecked(s.value(f'{pn}/import/combineHierarchicalRelations', True, bool))
        # export tab
        exMode = s.value(f'{pn}/export/mode', 'radioExGroup')
        next(rb.setChecked(True) for rb in (self.radioExGroup, self.radioExActiveLayer) if rb.objectName() == exMode)
        self.chkPermitDel.setChecked(s.value(f'{pn}/export/permitDeletions', False, bool))
        self.chkIgnoreUnconfFields.setChecked(s.value(f'{pn}/export/ignoreUnconfiguredFields', False, bool))

    def setConnectionEnabled(self, onOff: bool):
        self.connected = onOff
        self.selectImportCrs.setEnabled(onOff)
        self.selectExportCrs.setEnabled(onOff)
        self.radioFormatGPKG.setEnabled(onOff)
        self.radioFormatMemory.setEnabled(onOff)
        # import tab
        self.btnImport.setEnabled(onOff)
        self.chkSetAliases.setEnabled(onOff)
        self.chkCombineRel.setEnabled(onOff)
        # export tab
        self.selectExGroup.setEnabled(onOff)
        self.radioExGroup.setEnabled(onOff)
        self.radioExActiveLayer.setEnabled(onOff)
        self.chkPermitDel.setEnabled(onOff)
        self.chkIgnoreUnconfFields.setEnabled(onOff)
        self.btnExport.setEnabled(onOff)
        # on or off only
        if onOff:
            self.btnConnect.setText(self.tr('Disconnect'))
            self.selectCats.setEnabled(onOff)
        else:
            self.selectProject.setText('-')
            self.btnConnect.setText(self.tr('Connect'))
            self.selectCats.setEnabled(onOff)
            self.projectConfig = {}
            self.projectConfigCategories = {}

    def fieldConnect(self):
        """Connects to field and enables import/export form if the request was successful"""
        if self.connected:
            self.fieldDisconnect()
            return
        u: ParseResult = urlparse(self.lineEditServerAddress.text())
        # assign parsed parameters or use defaults if missing
        scheme = u.scheme or self.scheme  # http
        hostname = u.hostname or self.hostname  # localhost
        port = u.port or self.port  # 3000

        # create session
        self.api = ApiClient(u.password or self.lineEditPassword.text(), self, f'{scheme}://{hostname}:{port}')
        projectInfo = self.api.get('/info')
        if projectInfo:
            self.setConnectionEnabled(True)
            projectInfoJSON = projectInfo.json()
            self.fieldUser, self.fieldVersion = safe_get(projectInfoJSON, 'user'), safe_get(projectInfoJSON, 'version')
            self.activeProject = safe_get(projectInfoJSON, 'activeProject')
            self.toggleFieldInfo(self.fieldUser, self.fieldVersion)
            self.selectProject.setText(self.activeProject)
            self.setProjectCrs()

            # get config from active project as json
            self.projectConfig = self.api.get(f'/configuration/{self.activeProject}').json()
            self.projectConfigCategories = safe_get(self.projectConfig, 'categories')
            self.loadImportCategories()

            self.mB.pushSuccess(self.plugin_name, self.labels['FIELD_CONNECTED'])
            self.sB.showMessage(self.tr('Choose categories and format'))
            self.setConnectionStatus()

    def fieldImport(self):
        """Imports data from the currently active project in Field Desktop
        into QGIS, optionally as temporary layers or saved to disk into one geopackage"""
        if not self.api.isConnectionActive(): return
        lupLayerTemp = None

        # collect ui options
        csv_ui_opts = {
            'combineHierarchicalRelations': self.chkCombineRel.isChecked()
        }

        filename = None
        if self.radioFormatGPKG.isChecked():
            filename, filter = QFileDialog.getSaveFileName(
                self,
                self.tr('Save GeoPackage as...'),
                self.project.homePath(),
                'GeoPackage (*.gpkg)'
            )
            if not filename: return

        crs: QgsCoordinateReferenceSystem = self.selectImportCrs.crs()
        # get geojson first since its one file with all geometries
        rGeo: Response = self.api.get(f'/export/geojson?context=project&formatted=true')
        geoJSON = json.loads(rGeo.text)

        # create group at the bottom for inserting layers
        group_ref = self.treeRoot.insertGroup(-1, f'{self.activeProject}')

        cats = dict(zip([d for d in self.selectCats.checkedItemsData() if d], [i for i in self.selectCats.checkedItems() if i != self.labels['DESELECT_ALL']]))  # untranslated: translated

        for cat, label in cats.items():
            csv_reader = self.getCategoryCsv(cat, csv_ui_opts['combineHierarchicalRelations'])
            csv_header = csv_reader.fieldnames
            if self.chkSetAliases.isChecked():
                # merge without overwriting nested items
                csv_header_translations, valuemaps =  self.getCsvHeaderTranslations(cat)
                csv_header_translations = deep_merge(self.trAttrs, csv_header_translations)
                # print(f'csv_header_translations: {csv_header_translations}')
                # print(f'valuemaps: {valuemaps}')
            csv_rows = {row["identifier"]: row for row in csv_reader}
            # print(f'csv_rows: {csv_rows}')

            # create fields here for reuse
            fields = QgsFields()
            for col in csv_header:
                fields.append(QgsField(col, QVariant.String))

            # geom lookup
            geom_lookup = {safe_get(f['properties']['identifier']): f
                        for f in safe_get(geoJSON, 'features', default=[])}

            features = defaultdict(list)
            # iterate through csv
            for id, row in csv_rows.items():
                feat = QgsFeature(fields)
                feat.setAttributes(list(row.values()))

                # check if identifier is in geojson
                gj_feat = safe_get(geom_lookup, id)
                if gj_feat and safe_get(gj_feat, 'geometry'):
                    geom_json = json.dumps(gj_feat['geometry'])
                    geom = QgsJsonUtils.geometryFromGeoJson(geom_json)
                    if geom and not geom.isEmpty():
                        feat.setGeometry(geom)
                        geom_type = gj_feat['geometry']['type']
                    else:
                        geom_type = "NoGeometry"
                else:
                    geom_type = "NoGeometry"

                features[geom_type].append(feat)

            # add empty list in case there are no features, to add a schema only layer anyway
            if not features: features['NoGeometry'] = []

            for gType, feats in features.items():
                layType = GEOJSON_TO_QGIS.get(gType).name
                layNameSource = f'{self.activeProject}_{cat}'
                layName = f'{self.activeProject}_{label}'
                layer = QgsVectorLayer(layType, layName, 'memory')
                pr = layer.dataProvider()
                layer.setCrs(crs)
                pr.addAttributes(fields)
                layer.updateFields()

                pr.addFeatures(feats)
                layer.updateExtents()

                if self.chkSetAliases.isChecked():
                    layerFields = layer.fields()

                    # iterate through each field, split on dot and handle/translate
                    for i, field in enumerate(layerFields):
                        fname = field.name()
                        split = fname.split('.')  # dating 0 begin inputType
                        paths = []
                        parts = []
                        desc = ''
                        for part in split:
                            # skip numbers only
                            if re.findall('^\d+$', part):
                                parts.append(part)
                                continue

                            if len(part) == 2 and part in csv_header_translations:
                                parts.append(safe_get(csv_header_translations, part, 'label'))
                                continue

                            # build path to look for a translation - dating, dating.begin, dating.begin.inputType etc.
                            paths.append(part)

                            lookUp = safe_get(csv_header_translations, *paths, 'label', default=part)
                            if lookUp: parts.append(lookUp)

                            # set to latest description
                            desc = safe_get(csv_header_translations, *paths, 'description', default=desc)

                        if desc: layer.setConstraintExpression(i,'true', desc)

                        layer.setFieldAlias(i, ' '.join(parts))

                        # assign value map
                        if fname in valuemaps:
                            inputType = valuemaps[fname].get('type', '')
                            # handle checkboxes here
                            if inputType == 'checkboxes':
                                lup_entries = []
                                f_idx = layer.fields().indexFromName(fname)
                                # convert values to value relation compatible ones like "red;blue;green" to '{red,blue,green}'
                                for feature in layer.getFeatures():
                                    val = feature[f_idx]
                                    if isinstance(val, str) and ';' in val:
                                        parts = [p.strip() for p in val.split(';') if p.strip()]
                                        new_val = '{' + ','.join(parts) + '}'
                                        layer.dataProvider().changeAttributeValues({feature.id(): {f_idx: new_val}})

                                if not lupLayerTemp: lupLayerTemp:QgsVectorLayer = self.createLookupLayerTemp()
                                for k, v in valuemaps[fname].get('map', {}).items():
                                    # group_id, key, value, description
                                    f = QgsFeature()
                                    f.setFields(lupLayerTemp.fields())
                                    group_id = f'{cat}_{fname}'
                                    f['group_id'] = group_id
                                    f['key'] = k
                                    f['value'] = v
                                    f['description'] = ''
                                    # print(f'isValid: {f.isValid()}, {k}, {v}, {group_id}')
                                    # todo: show warning if not .isValid()
                                    lup_entries.append(f)
                                lupLayerTemp.dataProvider().addFeatures(lup_entries)
                                lupLayerTemp.updateFields()
                                lupLayerTemp.updateExtents()
                                # create value relation
                                vRelConfig = {
                                    'Layer': lupLayerTemp.id(),
                                    'Key': 'key',
                                    'Value': 'value',
                                    'FilterExpression': f'"group_id" = \'{group_id}\'',
                                    'AllowMulti': True,
                                    'UseCompleter': False,
                                }
                                layer.setEditorWidgetSetup(i, QgsEditorWidgetSetup('ValueRelation', vRelConfig))
                                valuemaps.pop(fname, None)
                                continue
                            else:
                                setup = QgsEditorWidgetSetup('ValueMap', valuemaps[fname])
                                layer.setEditorWidgetSetup(i, setup)
                                valuemaps.pop(fname, None)
                                continue

                        # test for composite field valuelists
                        if split[-1] in valuemaps:
                            # print(f'only composite field assigned? fname: {fname}')
                            setup = QgsEditorWidgetSetup('ValueMap', valuemaps[split[-1]])
                            layer.setEditorWidgetSetup(i, setup)
                            valuemaps.pop(split[-1], None)
                            continue

                        # lookups for vmaps
                        lup = {
                            # assign the valuemap with the key volume to the subfield measurementTechnique - info not in project config?
                            'volume': 'measurementTechnique',
                            'period': 'value',
                            'weight': 'measurementDevice',
                            'dimensionOther': 'measurementPosition',
                            'dimensionHeight': 'measurementPosition',
                            'dimensionDiameter': 'measurementPosition',
                            'dimensionWidth': 'measurementPosition',
                            'dimensionLength': 'measurementPosition',
                            'dimensionVerticalExtent': 'measurementPosition',
                            'dimensionThickness': 'measurementPosition',
                            'dimensionDepth': 'measurementPosition',
                            'dimensionPerimeter': 'measurementPosition',
                        }

                        for base, sub in lup.items():
                            if base in valuemaps and base in split and sub in split:
                                setup = QgsEditorWidgetSetup('ValueMap', valuemaps[base])
                                layer.setEditorWidgetSetup(i, setup)
                                # to see whats left unassigned at the end
                                valuemaps.pop(base, None)
                                break  # stop after first match

                    # python 3.12+
                    # if valuemaps: print(f'unassigned vmaps:\n{',\n'.join([f'{k}: {v}' for k,v in valuemaps.items()])}')
                    if valuemaps:
                        joined = ',\n'.join([f'{k}: {v}' for k, v in valuemaps.items()])
                        print(f'unassigned vmaps:\n{joined}')

                # write category to layer variables
                #! gets lost outside a saved project
                # todo: for export: try to read this first, then try english datasource name but set translated name as layername
                QgsExpressionContextUtils.setLayerVariable(layer, 'field_category', cat)

                # set layer definition to avoid writing NULL values which field rejects
                for i in range(len(fields)):
                    layer.setDefaultValueDefinition(i, QgsDefaultValue("''", False))

                # apply layer properties
                # change opacity
                if layer.wkbType() != QgsWkbTypes.NoGeometry:
                    layer.renderer().symbol().setOpacity(0.7)

                if filename:
                    if not filename.lower().endswith(".gpkg"):
                        filename += ".gpkg"
                    # print(filename)
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = 'gpkg'
                    options.layerName = f'{layNameSource}'
                    options.fileEncoding = 'UTF-8'
                    # primary key field needs to be of type integer
                    # options.layerOptions = ['FID=identifier']  # sets the primary key field for gpkg to prevent default fid field

                    transformContext = self.project.transformContext()

                    # CreateOrOverwriteFile needed first, after that CreateOrOverwriteLayer works
                    if not os.path.exists(filename): options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
                    else: options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer

                    error_code, error_message, new_filename, new_layer = \
                    QgsVectorFileWriter.writeAsVectorFormatV3(
                        layer,
                        filename,
                        transformContext,
                        options
                    )
                    # make layer persistent
                    layer.setDataSource(f'{filename}|layername={layNameSource}', layNameSource, 'ogr', False)
                    layer.setName(layName)

                    # print('error_code:', error_code, 'error_message:', error_message, 'new_filename:', new_filename, 'new_layer:', new_layer)
                    # python 3.10+
                    # match error_code:
                    #     case 0:
                    #         pass
                    #     case _:
                    #         self.mB.pushCritical(self.plugin_name, self.labels['IMPORT_FAILED'] + f': {error_message}')
                    #         self.sB.showMessage(self.labels['IMPORT_FAILED'], 10000)
                    #         return
                    if error_code == 0:
                        pass
                    else:
                        self.mB.pushCritical(self.plugin_name, self.labels['IMPORT_FAILED'] + f': {error_message}')
                        self.sB.showMessage(self.labels['IMPORT_FAILED'], 10000)
                        return

                # add layer to group_ref
                self.project.addMapLayer(layer, False)
                group_ref.insertLayer(-1, layer)

            # save style to geopackage
            # returns a tuple: flags representing whether QML or SLD storing was successful, msgError: a descriptive error message if any occurs
            if filename: layer.saveStyleToDatabaseV2(f'{cat}', self.tr('Style saved by the Field Connect plugin'), True, None, QgsMapLayer.AllStyleCategories)

        # add lookup layer
        if lupLayerTemp:
            self.project.addMapLayer(lupLayerTemp, True)
            if filename:
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                options.layerName = lupLayerTemp.name()
                QgsVectorFileWriter.writeAsVectorFormatV3(lupLayerTemp, filename, transformContext, options)
                lupLayerTemp.setDataSource(f'{filename}|layername={options.layerName}', options.layerName, 'ogr', False)
        # save qgis project to geopackage to keep value relations and layer variables
        if filename: self.project.write(f'geopackage:{filename}?projectName={self.activeProject}')

        self.mB.pushSuccess(self.plugin_name, self.labels['IMPORT_SUCCESS'])
        self.sB.showMessage(self.labels['IMPORT_SUCCESS'], 10000)

    def fieldExport(self):
        """Export group of layers back to Field Desktop using POST /import/{format}"""
        if not self.api.isConnectionActive(): return

        opts = {
            'coordinateTransform': None,
            'targetCrs': self.selectExportCrs.crs(),
            'groupExport': self.radioExGroup.isChecked(),
            'activeLayer': iface.activeLayer()
        }
        #! lowercase true/false important
        params = {
            'merge': 'false',
            'permitDeletions': str(self.chkPermitDel.isChecked()).lower(),
            'ignoreUnconfiguredFields': str(self.chkIgnoreUnconfFields.isChecked()).lower(),
            'categoryName': 'Project',  # default: Project, CSV only
            # 'operationIdentifier': '',  # default: unset - comboBox in gui? can only be activeProject anyway?
            'separator': ','  # default: ','
        }

        validGeomTypes = ('Polygon', 'Line', 'Point', 'No geometry')  # Other possible values: Unknown geometry, Invalid geometry
        # use layer group or create group with currently active layer
        if opts['groupExport']:
            cData = self.selectExGroup.currentData()
        elif opts['activeLayer']:
                tGroup = QgsLayerTreeGroup('temp')
                tGroup.addLayer(opts['activeLayer'])
                cData = tGroup
        else:
            self.mB.pushInfo(self.plugin_name, self.labels['INFO_NO_LAYER_SELECTED'])
            return
        if cData:
            # create dict with category and list of layers - cat:[*QgsVectorLayer]
            catLayers = defaultdict(list)
            for lTl in cData.findLayers():
                layer: QgsVectorLayer = lTl.layer()
                layerCrs: QgsCoordinateReferenceSystem = layer.crs()
                # ask for coordinate transformation once
                if layerCrs.isValid() and layerCrs.authid() != opts['targetCrs'].authid() and opts['coordinateTransform'] is None:
                    # todo: test message box
                    msg = QMessageBox(self)
                    msg.setWindowTitle(self.tr("Coordinate transformation"))
                    msg.setText(self.tr("The layer CRS differs from the target CRS. Do you want to transform coordinates?"))
                    msg.setIcon(QMessageBox.Question)

                    yes_button = msg.addButton(self.tr("Yes to all"), QMessageBox.YesRole)
                    no_button = msg.addButton(self.tr("No to all"), QMessageBox.NoRole)
                    cancel_button = msg.addButton(self.tr("Cancel"), QMessageBox.RejectRole)

                    msg.exec_()
                    clicked = msg.clickedButton()

                    if clicked == yes_button:
                        opts['coordinateTransform'] = True
                        return True
                    elif clicked == no_button:
                        opts['coordinateTransform'] = False
                        return True
                    elif clicked == cancel_button:
                        return False

                # abort if layer smells fishy
                if QgsWkbTypes.geometryDisplayString(layer.geometryType()) in validGeomTypes and layer.isValid():
                    cat = self.getCategoryNameForExport(layer)
                    if not cat:
                        self.mB.pushWarning(self.plugin_name, self.labels['CAT_NAME_EXTRACTION_FAILED'])
                        return
                    # check if cat is in Field Desktop, throw error and abort if not
                    # todo: self.getCategoryList()
                    catLayers[cat].append(layer)
                else:
                    self.mB.pushWarning(self.plugin_name, self.labels['LAYER_VALIDATION_FAILED'])
                    return
            # print(f'catLayers: {catLayers}')

            csv_exp_rows, gj_exp_geoms = defaultdict(list), defaultdict(list)
            # set geojson base structure
            gj_exp_geoms['type'] = 'FeatureCollection'
            # gj_exp_geoms['features'] = []

            # iterate through each catLayers type
            for category, layers in catLayers.items():
                # print(f'cat: {category}, layers: {layers}')
                for layer in layers:
                    # todo?: precision as ui param?
                    exporter = QgsJsonExporter(layer, precision=6)
                    exporter.setTransformGeometries(False)  # transforms to EPSG:4326 by default
                    exporter.setVectorLayer(layer)

                    unwanted = ('fid',)
                    fields = [f.name() for f in layer.fields() if f.name() not in unwanted]
                    # print(f'fields: {fields}')

                    for f in layer.getFeatures():
                        # --- GeoJSON feature ---
                        geom: QgsGeometry = f.geometry()
                        if not geom.isEmpty():
                            # todo: add selectExportCrs to top of method
                            if opts['coordinateTransform']:
                                exporter.setTransformGeometries(True)
                                exporter.setDestinationCrs(opts['targetCrs'])

                            # todo: refactor
                            gj_feature = exporter.exportFeature(f)  # returns dict-like JSON
                            gj_obj = json.loads(gj_feature)  # for removing unwanted fields like fid
                            # print(gj_obj['properties'].items())
                            # only keep identifier, category and shortDescription.xx properties
                            wanted = ('identifier', 'category', 'shortDescription')
                            filtered = {'properties': {}}
                            sd = {'shortDescription': {}}  # split shortDescription.xx into nested properties
                            # print(gj_obj['properties'])
                            for k,v in gj_obj['properties'].items():
                                # filters out shortDescriptionAddendum
                                if any(k==w or k.startswith(w + '.') for w in wanted):
                                    if k.startswith('shortDescription.'):
                                        lang = k.split('.')[-1]
                                        sd['shortDescription'][lang] = v
                                    else:
                                        # filtered['properties'] = {k: gj_obj['properties'][k]}
                                        filtered['properties'][k] = v
                            gj_obj['properties'] = filtered['properties']
                            sd_inner = sd.get('shortDescription')
                            if sd_inner: gj_obj['properties']['shortDescription'] = sd_inner
                            # add category property from layer name
                            gj_obj['properties']['category'] = category
                            gj_exp_geoms['features'].append(gj_obj)

                        # --- CSV row ---
                        # row = {field: f[field] for field in fields}
                        row = {}
                        for field_name in fields:
                            val = f[field_name]
                            idx = layer.fields().indexFromName(field_name)
                            setup = layer.editorWidgetSetup(idx)

                            if setup and setup.type() == 'ValueRelation':
                                # config = setup.config()
                                val = self.normalize_export_value(val)
                            row[field_name] = val

                        csv_exp_rows[category].append(row)
                    # print(csv_exp_rows[category])

            # upload csv here, after all data has been collected
            headers = {'Content-Type': 'text/csv; charset=utf-8'}
            for cat, rows in csv_exp_rows.items():
                if not rows: continue

                seen = set()
                fieldnames = [k for row in rows for k in row.keys() if not (k in seen or seen.add(k))]
                # print(f'fieldnames: {fieldnames}')

                csv_buffer = io.StringIO()
                writer = csv.DictWriter(csv_buffer, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(rows)

                csv_content = csv_buffer.getvalue()  # POST data
                csv_buffer.close()

                params['category'] = cat
                data = csv_content.encode('utf-8')
                params['merge'] = 'false'
                # print(f'Exporting {cat} as csv with merge=false...')
                # resp = \
                self.api.post('/import/csv', params=params, headers=headers, data=data)
                params['merge'] = 'true'
                # print(f'Exporting {cat} as csv with merge=true...')
                # resp = \
                self.api.post('/import/csv', params=params, headers=headers, data=data)

            # todo?: always the same params as csv export?
            # upload geojson here
            headers = {'Content-Type': 'application/geo+json'}
            data = json.dumps(gj_exp_geoms)
            params['merge'] = 'false'
            # print('Exporting GeoJSON with merge=false...')
            # resp = \
            self.api.post('/import/geojson', params=params, headers=headers, data=data)
            params['merge'] = 'true'
            # print('Exporting GeoJSON with merge=true...')
            # resp = \
            self.api.post('/import/geojson', params=params, headers=headers, data=data)

            # todo: success message
            # print(csv_exp_rows)
            # print(gj_exp_geoms)
        else: return

    # todo: use this in loadImportCategories - old?
    def getCategoryList(self):
        if self.api.isConnectionActive():
            return safe_get(self.api.get(f'/{self.activeProject}/configuration', 3001).json(), 'resource', 'order')
        else: return []

    # todo?: add context parameter?
    def getCategoryCsv(self, cat, cRelations=True):
        csv_opts = f'&schemaOnly=false&context=project&separator=,&combineHierarchicalRelations={str(cRelations).lower()}'
        rCsv = self.api.get(f'/export/csv?category={cat}{csv_opts}')
        rCsv.encoding = 'utf-8'

        return csv.DictReader(io.StringIO(rCsv.text))

    def fieldDisconnect(self):
        """
        Disconnects from Field Desktop and disables settings if a request fails
        """
        # disable import form, switch status led to red, hide connection info
        self.setConnectionEnabled(False)
        self.setConnectionStatus()
        self.toggleFieldInfo()

    def setConnectionStatus(self):
        glow = QGraphicsDropShadowEffect(self.labelConnectStatus)
        glow.setBlurRadius(15)
        glow.setOffset(0, 0)
        if self.connected:
            self.labelConnectStatus.setStyleSheet(f"""
                    background-color: green;
                    border-radius: 6px;
                    border: 1px solid #555;
                """)
            glow.setColor(QColor('green'))
        else:
            self.labelConnectStatus.setStyleSheet(f"""
                    background-color: red;
                    border-radius: 6px;
                    border: 1px solid #555;
                """)
            glow.setColor(QColor('red'))

        self.labelConnectStatus.setGraphicsEffect(glow)