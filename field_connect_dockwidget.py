# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FieldConnectDockWidget
                                 A QGIS plugin
 Connects to Field Desktop
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-08-18
        git sha              : $Format:%H$
        copyright            : (C) 2025 by VZG
        email                : oliver.zapiec@gbv.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, json, csv, io, re
from requests.models import Response
from urllib.parse import urlparse, ParseResult
from collections import defaultdict

from qgis.core import Qgis, QgsMessageLog, QgsApplication, QgsProject, QgsVectorLayer, QgsCoordinateReferenceSystem, \
QgsFields, QgsField, QgsGeometry, QgsJsonUtils, QgsFeature, QgsVectorFileWriter, QgsWkbTypes, \
QgsJsonExporter, QgsEditorWidgetSetup, QgsSettings, QgsDefaultValue, \
QgsExpressionContextUtils, QgsMapLayer, QgsLayerTreeGroup, QgsTask, NULL
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import Qt, QVariant, QTimer, pyqtSignal
from qgis.gui import QgsMessageBar
from qgis.utils import iface
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QStatusBar, QSizePolicy, QGraphicsDropShadowEffect, \
QMessageBox, QFormLayout, QLabel, QFileDialog, QApplication

from .modules.api_client import ApiClient
from .modules.cldr_loader import CLDRLoader
from .utils.constants import GEOJSON_TO_QGIS
from .utils.helpers import *
from .resources import *


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'field_connect_dockwidget_base.ui'))


class FieldConnectDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()
    def __init__(self, plugin_dir, locale, parent=None):
        """Constructor."""
        super(FieldConnectDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.loc = locale
        self.CLDRLoader = CLDRLoader(plugin_dir)
        self.CLDRTranslations = self.CLDRLoader.load_language_for(self.loc)

        # hide server address input in ui for now
        self.labelServerAddress.hide()
        self.lineEditServerAddress.hide()
        self.progressBar.hide()

        self.plugin_name = 'Field Connect'
        self.plugin_dir = plugin_dir
        self.project = QgsProject.instance()
        self.treeRoot = self.project.layerTreeRoot()
        self.projectConfig = {}  # /configuration/{project} :3000, not /{project}/configuration :3001
        self.projectConfigCategories = {}

        # show field information after connecting
        self.fieldUser = ''
        self.fieldVersion = ''
        self.activeProject = ''

        self.connected = False
        self._import_running = False
        self._export_running = False

        # weblate/linguist translation labels - extraction with pylupdate5 field_connect.pro
        self.labels = {
            'BAD_REQUEST': self.tr('Bad request'),
            'CONNECTION_LOST': self.tr('Connection lost!'),
            'CONNECTION_UNAUTHORIZED': self.tr('Unauthorized'),
            'DESELECT_ALL': self.tr('Deselect all'),
            'FIELD_CONNECTED': self.tr('Connected to Field Desktop'),
            'IMPORT_FAILED': self.tr('Import failed!'),
            'IMPORT_SUCCESS': self.tr('Import successful!'),
            'EXPORT_ERRORS': self.tr('Export finished with errors!'),
            'EXPORT_FAILED': self.tr('Export failed!'),
            'EXPORT_SUCCESS': self.tr('Export successful!'),
            'LAYER_VALIDATION_FAILED': self.tr('Layer validation failed!'),
            'CAT_NAME_EXTRACTION_FAILED': self.tr('Could not extract category name. Please set the layer variable "field_category" manually'),
            'NO_CATS_FOUND': self.tr('No categories found'),
            'REQUEST_FAILED': self.tr('Request failed'),
            'SELECT_ALL': self.tr('Select all'),
            'INFO_NO_LAYER_SELECTED': self.tr('No layer selected in the layer tree!'),
            'INFO_QUICK_EXPORT_NO_UNSAVED_LAYERS': self.tr('No unsaved layers for quick export available')
        }

        # manual attribute translations
        self.trAttrs = {
            'identifier': {'label': self.tr('Identifier'), 'description': self.tr('The unique identifier of the resource')},
            'date': {
                'value': {'label': self.tr('Value'), 'description': self.tr('The date specification for a single date; the start date for a date range')},
                'endValue': {'label': self.tr('End value'), 'description': self.tr('The end date for a date range')},
                'isRange': {'label': self.tr('Is range?'), 'description': self.tr('Indicates whether the date is a date range. Possible values are: true (date range), false (single date).')}
            },
            'relations': {
                'label': self.tr('Relation'),
                'isChildOf': {'label': self.tr('Is child of'), 'description': self.tr('Specifies the direct parent resource in the hierarchy; remains empty for top-level resources.')},
                'isRecordedIn': {'label': self.tr('Is recorded in'), 'description': self.tr('Specifies the operation in which the resource has been recorded; remains empty for top-level resources.')},
                'liesWithin': {'label': self.tr('Lies within'), 'description': self.tr('Specifies the direct parent resource in the hierarchy; remains empty for top-level resources or if the direct parent resource is an operation.')},
                'depicts': {'label': self.tr('Depicts'), 'description': self.tr('Links the image to one or more resources')},
                'isDepictedIn': {'label': self.tr('Is depicted in'), 'description': self.tr('Links the resource to one or more images.')},
                'isMapLayerOf': {'label': self.tr('Is map layer of'), 'description': self.tr('Adds the image as a map layer in the context of the resource specified as the target.')},
                'hasMapLayer': {'label': self.tr('Has map layer'), 'description': self.tr('Adds one or more images as a map layer in the context of this resource.')},
                'hasDefaultMapLayer': {'label': self.tr('Has default map layer'), 'description': self.tr('Specifies that the linked image is a default map layer in the context of this resource.')},
                'isInstanceOf': {'label': self.tr('Typological classification')}
            },
            'dating': {
                'type': {'label': self.tr('Type'), 'description': self.tr('The dating type. Possible values are: range (Period), single (Single year), before (Before), after (After), scientific (Scientific).')},
                'begin': {
                    'label': self.tr('Beginning:'),
                    'description': self.tr('Year specification that is set for the dating type "after" and as the start date for the dating type "range".'),
                    'inputType': {'label': self.tr('Dating system'), 'description': self.tr('The time scale. Possible values are: bce (BCE), ce (CE), bp (BP).')},
                    'inputYear': {'label': self.tr('Year'), 'description': self.tr('The year.')}
                },
                'end': {'label': self.tr('End:'), 'description': self.tr('Year specification that is set for the dating types "single", "before" and "scientific" and as the end date for the dating type "range".'),},
                'margin': {'label': self.tr('Margin'), 'description': self.tr('Tolerance margin in years for dating type "scientific".')},
                'source': {'label': self.tr('Source'), 'description': self.tr('Source of the dating.')},
                'isImprecise': {'label': self.tr('Is imprecise?'), 'description': self.tr('Specification "Imprecise". Cannot be set for dating type "scientific". Possible values are: true (yes), false (no).')},
                'isUncertain': {'label': self.tr('Is uncertain?'), 'description': self.tr('Specification "Uncertain". Cannot be set for dating type "scientific". Possible values are: true (yes), false (no).')},
            },
            'measurement': {
                'inputValue': {'label': self.tr('Value'), 'description': self.tr('The measured numerical value.')},
                'inputRangeEndValue': {'label': self.tr('End value'), 'description': self.tr('The second measured numerical value, if the dimension is a range.')},
                'measurementComment': {'label': self.tr('Comment')},
                'isImprecise': {'label': self.tr('Is imprecise?'), 'description': self.tr('Specification "Imprecise". Possible values are: true (yes), false (no).')},
            },
            'dimension': {
                'measurementPosition': {'label': self.tr('As measured by')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: mm, cm, m.')}
            },
            'weight': {
                'measurementDevice': {'label': self.tr('Measurement device')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: mg, g, kg.')}
            },
            'volume': {
                'measurementTechnique': {'label': self.tr('Measurement technique')},
                'inputUnit': {'label': self.tr('Unit'), 'description': self.tr('The unit of measurement. Possible values: ml, l.')}
            },
            'literature': {
                'quotation': {'label': self.tr('Literature quotation')},
                'zenonId': {'label': self.tr('Zenon ID')},
                'doi': {'label': self.tr('DOI')},
                'page': {'label': self.tr('Page')},
                'figure': {'label': self.tr('Figure')}
            },
            'period': {
                'label': self.tr('Period'),
                'value': {'label': self.tr('Value'), 'description': self.tr('The identifier of the selected value; if two values are selected, the first of the two values.')},
                'endValue': {'label': self.tr('End value'), 'description': self.tr('The identifier of the second selected value if two values are selected.')}
            }
        }
        # link identical translations
        self.trAttrs['dating']['end']['inputType'] = self.trAttrs['dating']['begin']['inputType']
        self.trAttrs['dating']['end']['inputYear'] = self.trAttrs['dating']['begin']['inputYear']
        self.trAttrs['dimension']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['dimension']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['dimension']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['dimension']['isImprecise'] = self.trAttrs['measurement']['isImprecise']
        self.trAttrs['weight']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['weight']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['weight']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['weight']['isImprecise'] = self.trAttrs['measurement']['isImprecise']
        self.trAttrs['volume']['inputValue'] = self.trAttrs['measurement']['inputValue']
        self.trAttrs['volume']['inputRangeEndValue'] = self.trAttrs['measurement']['inputRangeEndValue']
        self.trAttrs['volume']['measurementComment'] = self.trAttrs['measurement']['measurementComment']
        self.trAttrs['volume']['isImprecise'] = self.trAttrs['measurement']['isImprecise']

        # merge self.trAttrs into cldr dict
        if self.CLDRTranslations: self.trAttrs = deep_merge(self.CLDRTranslations, self.trAttrs)

        # layout
        self.toggleFieldInfo()
        self.selectImportCrs.setCrs(self.project.crs())
        self.selectExportCrs.setCrs(self.project.crs())
        self.formLayout.setWidget(self.formLayout.getWidgetPosition(self.hzLineSettings)[0], QFormLayout.SpanningRole, self.hzLineSettings)
        # add fullwidth for category selection
        # self.formLayout.setWidget(self.formLayout.getWidgetPosition(self.selectCats)[0], QFormLayout.SpanningRole, self.selectCats)
        self.setConnectionStatus()
        self.mB: QgsMessageBar = iface.messageBar()
        self.sB = QStatusBar()
        self.sB.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        self.sB.showMessage(self.tr("Ready to connect"))
        self.dockWidgetContents.layout().addWidget(self.sB)
        self.selectCats.view().setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        # export tab
        self.exportUpdateLayerGroups()
        # save settings on init, in case object names change
        self.saveSettings()
        # load saved settings
        self.loadSettings()

        # connections
        self.btnConnect.clicked.connect(self.fieldConnect)
        self.btnImport.clicked.connect(self.fieldImport)
        self.btnExport.clicked.connect(self.fieldExport)
        self.selectCats.model().itemChanged.connect(self.handleCats)
        self.tabWidget.currentChanged.connect(self.saveTabIndex)
        # export
        self.treeRoot.addedChildren.connect(self.exportUpdateLayerGroups)
        self.treeRoot.removedChildren.connect(self.exportUpdateLayerGroups)
        self.treeRoot.nameChanged.connect(self.exportUpdateLayerGroups)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def exportUpdateLayerGroups(self):
        self.selectExGroup.clear()
        gs = self.treeRoot.findGroups()
        [self.selectExGroup.addItem(group.name(), group) for group in gs] if gs else self.selectExGroup.addItem(self.tr('No groups available'))

    def setProjectCrs(self):
        """Sets the project crs when connecting to Field Desktop if available,
        or uses the one set in the QGIS Project"""
        epsgId = safe_get(self.api.get(f'/{self.activeProject}/project', port=3001).json(), 'resource', 'epsgId')
        crs = QgsCoordinateReferenceSystem(epsgId)

        if crs.isValid():
            self.project.setCrs(crs)
            self.selectImportCrs.setCrs(crs)
            self.selectExportCrs.setCrs(crs)
        else:
            projectCrs = self.project.crs()
            self.selectExportCrs.setCrs(projectCrs)
            self.selectExportCrs.setCrs(projectCrs)
            self.selectExportCrs.setCrs(projectCrs)
            self.mB.pushWarning(self.plugin_name, self.tr('Invalid EPSG Code in Field Desktop: {epsgId}. Using QGIS project CRS.').format(epsgId=epsgId))

    def normalize_export_value(self, value):
        """Normalize attribute values for CSV export.
        Converts QGIS multiselect formats {a,b,c} â†’ a;b;c, stripping any quotes."""

        if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
            inner = value[1:-1].strip()
            if inner:
                # remove any existing double quotes and split by comma
                parts = [p.strip().replace('"', '') for p in inner.split(',') if p.strip()]
                return ';'.join(parts)
            else:
                return ''
        elif value == NULL:
            return ''

        return value

    def toggleFieldInfo(self, user='', version='', activeProject=''):
        """Show user, version and active project when connected, hide if not"""
        d = {self.labelFieldUser:user, self.labelFieldVersion:version, self.labelFieldProject:activeProject}
        for k,v in d.items():
            row = self.formLayout.getWidgetPosition(k)[0]
            w = self.formLayout.itemAt(row, QFormLayout.FieldRole)
            if w:
                self.formLayout.removeWidget(w.widget())
            # k.setVisible(not k.isVisible())
            policy = k.sizePolicy()
            # only hide if disconnected
            if policy.horizontalPolicy() == QSizePolicy.Preferred and not self.connected:
                k.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
            elif self.connected:
                label = QLabel(v)
                self.formLayout.setWidget(row, QFormLayout.FieldRole, label)
                k.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

    # self.activeProject gets set when pressing the connect button and status == 200
    # currently unused as only the activeProject is selectable
    def isActiveProject(self, project):
        if self.activeProject != project:
            self.mB.pushMessage(': '.join([self.plugin_name, self.tr('Only the currently active project in Field Desktop can be imported!')]), Qgis.Warning, 5)

    # for de-/selecting items in the category field
    def handleCats(self, item):
        self.selectCats.model().blockSignals(True)
        row = self.selectCats.model().indexFromItem(item).row()
        # print(row)
        if row == 0:  # first de-/select all entry
            state = item.checkState()
            for i in range(1, self.selectCats.count()):
                self.selectCats.model().item(i).setCheckState(state)
            item.setText(self.labels['DESELECT_ALL'] if state == Qt.Checked else self.labels['SELECT_ALL'])
        else:
            # update the first item to reflect whether all other items are checked
            all_checked = all(self.selectCats.model().item(i).checkState() == Qt.Checked for i in range(1, self.selectCats.count()))
            self.selectCats.model().item(0).setCheckState(Qt.Checked if all_checked else Qt.Unchecked)
            self.selectCats.model().item(0).setText(self.labels['DESELECT_ALL'] if all_checked else self.labels['SELECT_ALL'])
        self.selectCats.model().blockSignals(False)

    def showOrHideProgressBar(self):
        """Shows the progress bar if an import/export is actively running or hides it if not"""
        self.progressBar.show() if (self._import_running or self._export_running) else self.progressBar.hide()

    def createLookupLayerTemp(self):
        """Create a temporary lookup layer for value relations for the Field Desktop input type 'checkboxes'"""
        fields = QgsFields()
        # fields.append(QgsField('id', QVariant.Int))
        # todo: QgsField constructor is deprecated
        fields.append(QgsField('group_id', QVariant.String))
        fields.append(QgsField('key', QVariant.String))
        fields.append(QgsField('value', QVariant.String))
        fields.append(QgsField('description', QVariant.String))

        lupLayer = QgsVectorLayer(
            'None',   # no geometry
            f'{self.activeProject}_lookup',
            "memory"
        )

        pr = lupLayer.dataProvider()
        pr.addAttributes(fields)
        lupLayer.updateFields()

        return lupLayer

    # dataSourceUri: .gpkg|layername=.*_CategoryName'
    def getCategoryNameForExport(self, layer: QgsVectorLayer):
        """Extract the category name from the layer variable 'field_category' which is set on import, or
        try the dataSourceUri as fallback"""
        catName = QgsExpressionContextUtils.layerScope(layer).variable('field_category') or layer.dataProvider().dataSourceUri().split('_')[-2] or ''

        return catName

    def loadImportCategories(self):
        """Loads available categories for import with translated labels
        and their original name as userData."""
        self.selectCats.clear()
        cats = []

        def collect_categories(node):
            """
            Recursively collect categories from nested dict/list structures.
            """
            if not isinstance(node, dict): return

            item = node.get("item")
            if isinstance(item, dict) and "name" in item:
                uLabel = item["name"]
                tLabel = safe_get(item, "label", self.loc)
                cats.append((tLabel or uLabel, uLabel))

            # Recurse into subtrees
            trees = node.get("trees")
            if isinstance(trees, list):
                for sub in trees:
                    collect_categories(sub)

        categories = self.projectConfig.get("categories")
        if isinstance(categories, dict):
            collect_categories(categories)
        elif isinstance(categories, list):
            for cat in categories:
                collect_categories(cat)

        if cats:
            self.selectCats.addItem(self.labels['SELECT_ALL'])
            for label, name in cats:
                self.selectCats.addItem(label, name)
        else:
            self.selectCats.model().blockSignals(True)
            self.selectCats.clear()
            self.selectCats.addItem(self.labels['NO_CATS_FOUND'])
            self.selectCats.setCurrentIndex(0)
            self.selectCats.setItemCheckState(0, Qt.Checked)
            self.selectCats.setEnabled(False)
            self.selectCats.model().blockSignals(False)
            return
        self.selectCats.setEnabled(True)

    # todo: change method name as it does more than get translations now
    def getCsvHeaderTranslations(self, cat):  # ðŸ±
        """Get translations from the project config.
        Ignores the category field as it is not getting exported in a CSV export.
        Moves relation fields into a nested 'relations' dict.
        Moves composite fields into nested dicts keyed by their 'name'.
        Also collects value maps from valuelist properties for later assignment."""
        translations = {'identifier': {'inputType': 'identifier'}, 'relations': {'inputType': 'relation'}}
        valuemaps = {}

        def recurse(data, result, seen=None, path='root'):
            """Recursively collect field translations for the given locale."""
            if seen is None:
                seen = set()

            if isinstance(data, dict):
                if 'name' in data and isinstance(data['name'], str):
                    fieldname = data['name']
                    inputType = data.get('inputType', '')
                    if fieldname != 'category':
                        if fieldname in seen:
                            print(f'Duplicate field "{fieldname}" found at {path}')
                        seen.add(fieldname)

                        # try to get translated label for the current locale
                        label = data.get('label', {}).get(self.loc, fieldname)
                        description = data.get('description', {}).get(self.loc, '')
                        if not description:
                            description = data.get('description', {}).get('en', '')

                        if 'valuelist' in data:
                            vmap = {}
                            values = data['valuelist'].get('values', {})
                            for key, vdef in values.items():
                                vlabel = vdef.get('label', {}).get(self.loc, key)
                                vmap[vlabel] = key  # vmaps need the format description:value, although the gui says value:description
                            if vmap:
                                # add empty string option to clear selection
                                if '' not in vmap and inputType != 'checkboxes': vmap[''] = ''
                                valuemaps[fieldname] = {'map': vmap, 'inputType': inputType}

                        # handle relation fields
                        if data.get('inputType') == 'relation':
                            result.setdefault('relations', {})[fieldname] = {
                                'label': label,
                                'description': description,
                                'inputType': inputType
                            }

                        # handle composite fields
                        elif data.get('inputType') == 'composite':
                            comp = result.setdefault(fieldname, {
                                'label': label,
                                'description': description,
                                'inputType': inputType
                            })
                            # collect subfields as nested entries
                            subfields = data.get('subfields', [])
                            if isinstance(subfields, list):
                                for sf in subfields:
                                    sf_name = sf.get('name')
                                    if not sf_name:
                                        continue
                                    sf_label = sf.get('label', {}).get(self.loc, sf_name)
                                    sf_descr = sf.get('description', {}).get(self.loc, '')
                                    sf_inputType = sf.get('inputType', {})
                                    if not sf_descr:
                                        sf_descr = sf.get('description', {}).get('en', '')
                                    comp[sf_name] = {
                                        'label': sf_label,
                                        'description': sf_descr,
                                        'inputType': sf_inputType
                                    }

                                    if 'valuelist' in sf:
                                        vmap = {}
                                        values = sf['valuelist'].get('values', {})
                                        for key, vdef in values.items():
                                            vlabel = vdef.get('label', {}).get(self.loc, key)
                                            vmap[vlabel] = key
                                        if vmap:
                                            if '' not in vmap and inputType != 'checkboxes': vmap[''] = ''
                                            valuemaps[sf_name] = {'map': vmap, 'inputType': sf_inputType}

                            data = {k: v for k, v in data.items() if k != 'subfields'}
                        # regular fields
                        else:
                            result[fieldname] = {
                                'label': label,
                                'description': description,
                                'inputType': inputType
                            }

                # recurse into nested structures
                for k, v in data.items():
                    recurse(v, result, seen, f'{path}.{k}')

            elif isinstance(data, list):
                for i, item in enumerate(data):
                    recurse(item, result, seen, f'{path}[{i}]')

            return result

        fCat = None
        for d in safe_get(self.projectConfig, 'categories', default=[]):
            # check top-level category name
            if safe_get(d, 'item', 'name') == cat:
                fCat = d
                break

            # check nested trees within category
            for t in safe_get(d, 'trees', default=[]):
                if safe_get(t, 'item', 'name') == cat:
                    fCat = t
                    break
            if fCat:
                break

        if fCat:
            # recurse through the category to find all field definitions
            fGroups = safe_get(fCat, 'item', 'groups')
            if fGroups:
                for group in fGroups:
                    recurse(group, translations)
            fTrees = safe_get(fCat, 'item')
            if fTrees:
                for group in fTrees:
                    recurse(group, translations)

        return translations, valuemaps

    def saveTabIndex(self, idx):
        """Save tab index separately as it resets to 0 when reloading the plugin"""
        pn = self.plugin_name.replace(' ', '').lower()
        s = QgsSettings()
        s.setValue(f'{pn}/activeTabIndex', idx)

    def saveSettings(self):
        """Save user settings made in the ui"""
        pn = self.plugin_name.replace(' ', '').lower()
        s = QgsSettings()
        # import tab
        s.setValue(f'{pn}/import/format', self.radioFormatMemory.objectName() if self.radioFormatMemory.isChecked() else self.radioFormatGPKG.objectName())
        s.setValue(f'{pn}/import/setalias', self.chkSetAliases.isChecked())
        s.setValue(f'{pn}/import/combineHierarchicalRelations', self.chkCombineRel.isChecked())
        # export tab
        s.setValue(f'{pn}/export/mode', self.radioExGroup.objectName() if self.radioExGroup.isChecked() else self.radioExSelectedLayers.objectName())
        s.setValue(f'{pn}/export/quickExport', self.chkQuickExport.isChecked())
        s.setValue(f'{pn}/export/commitSave', self.chkCommitSave.isChecked())
        s.setValue(f'{pn}/export/permitDeletions', self.chkPermitDel.isChecked())
        s.setValue(f'{pn}/export/ignoreUnconfiguredFields', self.chkIgnoreUnconfFields.isChecked())

    def loadSettings(self):
        """Load user settings made in the ui"""
        pn = self.plugin_name.replace(' ', '').lower()
        s = QgsSettings()
        self.tabWidget.setCurrentIndex(s.value(f'{pn}/activeTabIndex', 0, int))
        # import tab
        rbName = s.value(f'{pn}/import/format', 'radioFormatMemory')
        next(rb.setChecked(True) for rb in (self.radioFormatMemory, self.radioFormatGPKG) if rb.objectName() == rbName)
        self.chkSetAliases.setChecked(s.value(f'{pn}/import/setalias', True, bool))
        self.chkCombineRel.setChecked(s.value(f'{pn}/import/combineHierarchicalRelations', True, bool))
        # export tab
        exMode = s.value(f'{pn}/export/mode', 'radioExGroup')
        next(rb.setChecked(True) for rb in (self.radioExGroup, self.radioExSelectedLayers) if rb.objectName() == exMode)
        self.chkQuickExport.setChecked(s.value(f'{pn}/export/quickExport', False, bool))
        self.chkCommitSave.setChecked(s.value(f'{pn}/export/commitSave', True, bool))
        self.chkPermitDel.setChecked(s.value(f'{pn}/export/permitDeletions', False, bool))
        self.chkIgnoreUnconfFields.setChecked(s.value(f'{pn}/export/ignoreUnconfiguredFields', False, bool))

    def setConnectionEnabled(self, onOff: bool):
        self.connected = onOff
        self.selectImportCrs.setEnabled(onOff)
        self.selectExportCrs.setEnabled(onOff)
        self.radioFormatGPKG.setEnabled(onOff)
        self.radioFormatMemory.setEnabled(onOff)
        # import tab
        self.btnImport.setEnabled(onOff)
        self.chkSetAliases.setEnabled(onOff)
        self.chkCombineRel.setEnabled(onOff)
        # export tab
        self.selectExGroup.setEnabled(onOff)
        self.radioExGroup.setEnabled(onOff)
        self.radioExSelectedLayers.setEnabled(onOff)
        self.chkQuickExport.setEnabled(onOff)
        self.chkCommitSave.setEnabled(onOff)
        self.chkPermitDel.setEnabled(onOff)
        self.chkIgnoreUnconfFields.setEnabled(onOff)
        self.btnExport.setEnabled(onOff)
        # on or off only
        if onOff:
            self.btnConnect.setText(self.tr('Disconnect'))
            self.selectCats.setEnabled(onOff)
        else:
            self.btnConnect.setText(self.tr('Connect'))
            self.selectCats.setEnabled(onOff)
            self.projectConfig = {}
            self.projectConfigCategories = {}
            self.fieldUser = ''
            self.fieldVersion = ''
            self.activeProject = ''
            self._import_running = False
            self._export_running = False

    def fieldConnect(self):
        """Connects to field and enables import/export form if the request was successful"""
        if self.connected:
            self.fieldDisconnect()
            return
        u: ParseResult = urlparse(self.lineEditServerAddress.text())
        # assign parsed parameters or use defaults if missing
        scheme = u.scheme or self.scheme  # http
        hostname = u.hostname or self.hostname  # localhost
        port = u.port or self.port  # 3000

        # create session
        self.api = ApiClient(u.password or self.lineEditPassword.text(), self, f'{scheme}://{hostname}:{port}')
        projectInfo = self.api.get('/info')
        if projectInfo:
            self.setConnectionEnabled(True)
            projectInfoJSON = projectInfo.json()
            self.fieldUser, self.fieldVersion, self.activeProject = safe_get(projectInfoJSON, 'user'), safe_get(projectInfoJSON, 'version'), safe_get(projectInfoJSON, 'activeProject')
            self.toggleFieldInfo(self.fieldUser, self.fieldVersion, self.activeProject)
            self.setProjectCrs()

            # get config from active project as json
            self.projectConfig = self.api.get(f'/configuration/{self.activeProject}').json()
            self.projectConfigCategories = safe_get(self.projectConfig, 'categories')
            self.loadImportCategories()

            self.mB.pushSuccess(self.plugin_name, self.labels['FIELD_CONNECTED'])
            self.sB.showMessage(self.tr('Choose categories and format'))
            self.setConnectionStatus()

    # todo: check if self.activeProject is still the same as the currently open project in field
    def fieldImport(self):
        """Imports data from the currently active project in Field Desktop
        into QGIS, optionally as temporary layers or saved to disk into one geopackage"""
        if not self.api.isConnectionActive(): return
        self._import_running = True
        self.progressBar.reset()
        self.showOrHideProgressBar()
        activeGrp = None
        lNames = []
        lupLayerTemp = None
        processed_vmaps = []

        # collect ui options
        csv_ui_opts = {
            'combineHierarchicalRelations': self.chkCombineRel.isChecked()
        }

        filename = None
        import_overwrite = False  # check if file path exists for handling/updating existing geopackages
        if self.radioFormatGPKG.isChecked():
            filename, filter = QFileDialog.getSaveFileName(
                self,
                self.tr('Save GeoPackage as...'),
                self.project.homePath(),
                'GeoPackage (*.gpkg)'
            )
            if not filename:
                self._import_running = False
                self.showOrHideProgressBar()
                return
            elif os.path.exists(filename):
                import_overwrite = True

        if import_overwrite:
            # takes the first group from the top if there are multiple with the same name
            activeGrp = self.project.layerTreeRoot().findGroup(self.activeProject)
            lNames = [l.name() for l in activeGrp.findLayers()]

        crs: QgsCoordinateReferenceSystem = self.selectImportCrs.crs()
        # get geojson first since its one file with all geometries
        rGeo: Response = self.api.get(f'/export/geojson?context=project&formatted=true')
        geoJSON = json.loads(rGeo.text)

        # create group at the bottom for inserting layers
        if not import_overwrite: group_ref = self.treeRoot.insertGroup(-1, f'{self.activeProject}')

        cats = dict(zip([d for d in self.selectCats.checkedItemsData() if d], [i for i in self.selectCats.checkedItems() if i != self.labels['DESELECT_ALL']]))  # untranslated: translated

        self.progressBar.setMaximum(len(cats))

        for i, (cat, label) in enumerate(cats.items()):
            self.progressBar.setValue(i)
            self.progressBar.setFormat(self.tr('Importing category {label} %p%').format(label=label))
            QApplication.processEvents()

            csv_reader = self.getCategoryCsv(cat, csv_ui_opts['combineHierarchicalRelations'])
            csv_header = csv_reader.fieldnames
            if self.chkSetAliases.isChecked():
                # merge without overwriting nested items
                csv_header_translations, valuemaps =  self.getCsvHeaderTranslations(cat)
                csv_header_translations = deep_merge(csv_header_translations, self.trAttrs)
                # print(f'csv_header_translations: {csv_header_translations}')
                # print(f'valuemaps: {valuemaps}')
            csv_rows = {row["identifier"]: row for row in csv_reader}
            # print(f'csv_rows: {csv_rows}')

            # create fields here for reuse
            fields = QgsFields()
            for col in csv_header:
                fields.append(QgsField(col, QVariant.String))

            # geom lookup
            geom_lookup = {safe_get(f['properties']['identifier']): f
                        for f in safe_get(geoJSON, 'features', default=[])}

            features = defaultdict(list)
            # iterate through csv
            for id, row in csv_rows.items():
                feat = QgsFeature(fields)
                feat.setAttributes(list(row.values()))

                # check if identifier is in geojson
                gj_feat = safe_get(geom_lookup, id)
                if gj_feat and safe_get(gj_feat, 'geometry'):
                    geom_json = json.dumps(gj_feat['geometry'])
                    geom = QgsJsonUtils.geometryFromGeoJson(geom_json)
                    if geom and not geom.isEmpty():
                        feat.setGeometry(geom)
                        geom_type = gj_feat['geometry']['type']
                    else:
                        geom_type = "NoGeometry"
                else:
                    geom_type = "NoGeometry"

                features[geom_type].append(feat)

            # add empty list in case there are no features, to add a schema only layer anyway
            if not features: features['NoGeometry'] = []

            for gType, feats in features.items():
                layType = GEOJSON_TO_QGIS.get(gType).name
                layNameSource = f'{self.activeProject}_{cat}_{gType}'
                layName = f'{self.activeProject}_{label}_{gType}'
                layer = QgsVectorLayer(layType, layName, 'memory')
                pr = layer.dataProvider()
                layer.setCrs(crs)
                pr.addAttributes(fields)
                layer.updateFields()

                pr.addFeatures(feats)
                layer.updateExtents()

                if self.chkSetAliases.isChecked():
                    layerFields = layer.fields()

                    # iterate through each field, split on dot and handle/translate
                    for fIdx, field in enumerate(layerFields):
                        fname = field.name()
                        split = fname.split('.')  # dating 0 begin inputType
                        inputType = safe_get(csv_header_translations, split[0], 'inputType', default='')
                        paths = []
                        parts = []
                        desc = ''
                        for idx, part in enumerate(split):
                            # skip numbers only
                            if re.findall('^\d+$', part):
                                parts.append(part)
                                continue

                            if len(part) == 2 and part in csv_header_translations:
                                parts.append(safe_get(csv_header_translations, part, 'label', default=part))
                                paths.append(part)
                                continue

                            # skip first two parts (dimensionLength.0)
                            if (idx > 1) and inputType in ('dimension', 'volume', 'weight', 'dating', 'literature'):
                                # get translation from {inputType} or measurement key, if available in self.trAttrs
                                paths.append(part)
                                parts.append(safe_get(csv_header_translations, inputType, *paths[1:], 'label', default=False) or safe_get(csv_header_translations, 'measurement', part, 'label', default=part))
                                continue

                            # build path to look for a translation - dating, dating.begin, dating.begin.inputType etc.
                            paths.append(part)

                            lookUp = safe_get(csv_header_translations, *paths, 'label', default=part)
                            if lookUp: parts.append(lookUp)

                            # set to latest description
                            desc = safe_get(csv_header_translations, *paths, 'description', default=desc)

                        if desc: layer.setConstraintExpression(fIdx,'true', desc)

                        layer.setFieldAlias(fIdx, ' '.join(parts))

                        # assign value map
                        if fname in valuemaps:
                            # handle checkboxes here
                            if inputType == 'checkboxes':
                                lup_entries = []
                                f_idx = layer.fields().indexFromName(fname)
                                # convert values to value relation compatible ones like "red;blue;green" to '{red,blue,green}'
                                for feature in layer.getFeatures():
                                    val = feature[f_idx]
                                    if isinstance(val, str) and ';' in val:
                                        parts = [p.strip() for p in val.split(';') if p.strip()]
                                        new_val = '{' + ','.join(parts) + '}'
                                        layer.dataProvider().changeAttributeValues({feature.id(): {f_idx: new_val}})

                                if not lupLayerTemp: lupLayerTemp:QgsVectorLayer = self.createLookupLayerTemp()
                                group_id = f'{cat}_{fname}'
                                if group_id not in processed_vmaps:
                                    processed_vmaps.append(group_id)
                                    for k, v in valuemaps[fname].get('map', {}).items():
                                        # group_id, key, value, description
                                        f = QgsFeature()
                                        f.setFields(lupLayerTemp.fields())
                                        f['group_id'] = group_id
                                        f['key'] = k
                                        f['value'] = v
                                        f['description'] = ''
                                        # print(f'isValid: {f.isValid()}, {k}, {v}, {group_id}')
                                        # todo: show warning if not .isValid()
                                        lup_entries.append(f)
                                    lupLayerTemp.dataProvider().addFeatures(lup_entries)
                                    lupLayerTemp.updateFields()
                                    lupLayerTemp.updateExtents()
                                # create value relation
                                vRelConfig = {
                                    'Layer': lupLayerTemp.id(),
                                    'Key': 'key',
                                    'Value': 'value',
                                    'FilterExpression': f'"group_id" = \'{group_id}\'',
                                    'AllowMulti': True,
                                    'UseCompleter': False,
                                }
                                layer.setEditorWidgetSetup(fIdx, QgsEditorWidgetSetup('ValueRelation', vRelConfig))
                                continue
                            else:
                                setup = QgsEditorWidgetSetup('ValueMap', valuemaps[fname])
                                layer.setEditorWidgetSetup(fIdx, setup)
                                continue
                        # handle type dropdownRange which has the subfields value and endValue
                        elif inputType == 'dropdownRange':
                            setup = QgsEditorWidgetSetup('ValueMap', valuemaps[split[0]])
                            layer.setEditorWidgetSetup(fIdx, setup)
                            continue

                        # test for composite field valuelists
                        if split[-1] in valuemaps:
                            # print(f'only composite field assigned? fname: {fname}')
                            setup = QgsEditorWidgetSetup('ValueMap', valuemaps[split[-1]])
                            layer.setEditorWidgetSetup(fIdx, setup)
                            continue

                        # lookups for vmaps
                        lup = {
                            # assign the valuemap with the key volume to the subfield measurementTechnique - info not in project config?
                            'volume': ['measurementTechnique'],
                            # 'period': ['value', 'endValue'],  # assigned in inputType dropdownRange
                            'weight': ['measurementDevice'],
                            'dimensionOther': ['measurementPosition'],
                            'dimensionHeight': ['measurementPosition'],
                            'dimensionDiameter': ['measurementPosition'],
                            'dimensionWidth': ['measurementPosition'],
                            'dimensionLength': ['measurementPosition'],
                            'dimensionVerticalExtent': ['measurementPosition'],
                            'dimensionThickness': ['measurementPosition'],
                            'dimensionDepth': ['measurementPosition'],
                            'dimensionPerimeter': ['measurementPosition'],
                        }

                        for base, sub in lup.items():
                            if base in valuemaps and base in split and any(s in split for s in sub):
                                setup = QgsEditorWidgetSetup('ValueMap', valuemaps[base])
                                layer.setEditorWidgetSetup(fIdx, setup)
                                break  # stop after first match

                    # python 3.12+
                    # todo: compare valuemaps to processed_vmaps to find unassigned vmaps
                    # if valuemaps: print(f'unassigned vmaps:\n{',\n'.join([f'{k}: {v}' for k,v in valuemaps.items()])}')
                    # if valuemaps:
                    #     joined = ',\n'.join([f'{k}: {v}' for k, v in valuemaps.items()])
                    #     print(f'unassigned vmaps:\n{joined}')

                # write category to layer variables
                #! gets lost outside a saved project
                QgsExpressionContextUtils.setLayerVariable(layer, 'field_category', cat)

                # set layer definition to avoid writing NULL values which field rejects
                for j in range(len(fields)):
                    layer.setDefaultValueDefinition(j, QgsDefaultValue("''", False))

                # apply layer properties
                # change opacity
                if layer.wkbType() != QgsWkbTypes.NoGeometry:
                    layer.renderer().symbol().setOpacity(0.7)

                if filename:
                    if not filename.lower().endswith(".gpkg"):
                        filename += ".gpkg"
                    # print(filename)
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = 'gpkg'
                    options.layerName = f'{layNameSource}'
                    options.fileEncoding = 'UTF-8'
                    # primary key field needs to be of type integer
                    # options.layerOptions = ['FID=identifier']  # sets the primary key field for gpkg to prevent default fid field

                    transformContext = self.project.transformContext()

                    # CreateOrOverwriteFile needed first, after that CreateOrOverwriteLayer works
                    if not os.path.exists(filename): options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
                    else: options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer

                    error_code, error_message, new_filename, new_layer = \
                    QgsVectorFileWriter.writeAsVectorFormatV3(
                        layer,
                        filename,
                        transformContext,
                        options
                    )
                    # make layer persistent
                    if layName not in lNames:
                        layer.setDataSource(f'{filename}|layername={layNameSource}', layNameSource, 'ogr', False)
                        layer.setName(layName)

                    # print('error_code:', error_code, 'error_message:', error_message, 'new_filename:', new_filename, 'new_layer:', new_layer)
                    # python 3.10+
                    # match error_code:
                    #     case 0:
                    #         pass
                    #     case _:
                    #         self.mB.pushCritical(self.plugin_name, self.labels['IMPORT_FAILED'] + f': {error_message}')
                    #         self.sB.showMessage(self.labels['IMPORT_FAILED'], 10000)
                    #         return
                    if error_code == 0:
                        pass
                    else:
                        self.mB.pushCritical(self.plugin_name, self.labels['IMPORT_FAILED'] + f': {error_message}')
                        self.sB.showMessage(self.labels['IMPORT_FAILED'], 10000)
                        return

                if not import_overwrite:
                    # add layer to group_ref
                    self.project.addMapLayer(layer, False)
                    group_ref.insertLayer(-1, layer)
                elif activeGrp:
                    # only add layers that are not in the self.activeProject group
                    if layName not in lNames:
                        self.project.addMapLayer(layer, False)
                        activeGrp.insertLayer(-1, layer)

            # save style to geopackage
            # returns a tuple: flags representing whether QML or SLD storing was successful, msgError: a descriptive error message if any occurs
            if filename and not import_overwrite: layer.saveStyleToDatabaseV2(f'{cat}', self.tr('Style saved by the Field Connect plugin'), True, None, QgsMapLayer.AllStyleCategories)
            self.progressBar.setValue(i+1)
            QApplication.processEvents()

        # add lookup layer
        if lupLayerTemp:
            if not import_overwrite: self.project.addMapLayer(lupLayerTemp, True)
            if filename:
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                options.layerName = lupLayerTemp.name()
                QgsVectorFileWriter.writeAsVectorFormatV3(lupLayerTemp, filename, transformContext, options)
                if not import_overwrite: lupLayerTemp.setDataSource(f'{filename}|layername={options.layerName}', options.layerName, 'ogr', False)
        # save qgis project to geopackage to keep value relations and layer variables - overwrites existing project
        if filename: self.project.write(f'geopackage:{filename}?projectName={self.activeProject}')

        # refresh layers after overwriting data
        if import_overwrite:
            # todo: find a better way to refresh layers
            # layer.dataProvider().forceReload() and layer.triggerRepaint() only worked in console
            # and iface.mapCanvas().refresh() didnt work at all
            QgsProject.instance().reloadAllLayers()

        self.mB.pushSuccess(self.plugin_name, self.labels['IMPORT_SUCCESS'])
        self.sB.showMessage(self.labels['IMPORT_SUCCESS'], 10000)
        self._import_running = False
        QTimer.singleShot(2000, self.showOrHideProgressBar)

    def fieldExport(self):
        """Export group of layers back to Field Desktop using POST /import/{format}"""
        if not self.api.isConnectionActive(): return
        self.progressBar.reset()
        self._export_running = True
        _export_unsaved_layers = None
        _export_errors = False
        self.showOrHideProgressBar()

        opts = {
            'coordinateTransform': None,
            'targetCrs': self.selectExportCrs.crs(),
            'groupExport': self.radioExGroup.isChecked(),
            'selectedLayers': iface.layerTreeView().selectedLayers(),
            'quickExport': self.chkQuickExport.isChecked(),
            'commitSave': self.chkCommitSave.isChecked()
        }
        #! lowercase true/false important
        params = {
            'merge': 'false',
            'permitDeletions': str(self.chkPermitDel.isChecked()).lower(),
            'ignoreUnconfiguredFields': str(self.chkIgnoreUnconfFields.isChecked()).lower(),
            'categoryName': 'Project',  # default: Project, CSV only
            # 'operationIdentifier': '',  # default: unset - comboBox in gui? can only be activeProject anyway?
            'separator': ','  # default: ','
        }

        validGeomTypes = ('Polygon', 'Line', 'Point', 'No geometry')  # Other possible values: Unknown geometry, Invalid geometry
        # use layer group or create group with currently active layer
        if opts['groupExport']:
            cData = self.selectExGroup.currentData()
        elif opts['selectedLayers']:
            tGroup = QgsLayerTreeGroup('temp')
            for lay in opts['selectedLayers']:
                tGroup.addLayer(lay)
            cData = tGroup
        else:
            self.mB.pushInfo(self.plugin_name, self.labels['INFO_NO_LAYER_SELECTED'])
            cData = None
        if cData:
            # create dict with category and list of layers - cat:[*QgsVectorLayer]
            # todo?: get count for progress bar here?
            catLayers = defaultdict(list)
            for lTl in cData.findLayers():
                layer: QgsVectorLayer = lTl.layer()
                layerCrs: QgsCoordinateReferenceSystem = layer.crs()
                # ask for coordinate transformation once
                if layerCrs.isValid() and layerCrs.authid() != opts['targetCrs'].authid() and opts['coordinateTransform'] is None:
                    msg = QMessageBox(self)
                    msg.setWindowTitle(self.tr("Coordinate transformation"))
                    msg.setText(self.tr("The layer CRS differs from the target CRS. Do you want to transform coordinates?"))
                    msg.setIcon(QMessageBox.Question)

                    yes_button = msg.addButton(self.tr("Yes to all"), QMessageBox.YesRole)
                    no_button = msg.addButton(self.tr("No to all"), QMessageBox.NoRole)
                    cancel_button = msg.addButton(self.tr("Cancel"), QMessageBox.RejectRole)

                    msg.exec_()
                    clicked = msg.clickedButton()

                    if clicked == yes_button:
                        opts['coordinateTransform'] = True
                    elif clicked == no_button:
                        opts['coordinateTransform'] = False
                    elif clicked == cancel_button:
                        self._export_running = False
                        self.showOrHideProgressBar()
                        return

                # abort if layer smells fishy
                if QgsWkbTypes.geometryDisplayString(layer.geometryType()) in validGeomTypes and layer.isValid():
                    cat = self.getCategoryNameForExport(layer)
                    if not cat:
                        self.mB.pushWarning(self.plugin_name, self.labels['CAT_NAME_EXTRACTION_FAILED'])
                        return
                    # check if cat is in Field Desktop, throw error and abort if not
                    # todo: self.getCategoryList()
                    catLayers[cat].append(layer)
                else:
                    self.mB.pushWarning(self.plugin_name, self.labels['LAYER_VALIDATION_FAILED'])
                    return
            # print(f'catLayers: {catLayers}')

            csv_exp_rows, gj_exp_geoms = defaultdict(list), defaultdict(list)
            # set geojson base structure
            gj_exp_geoms['type'] = 'FeatureCollection'
            gj_exp_geoms['features'] = []

            total_cats = len(catLayers)
            self.progressBar.setMaximum(total_cats + 1)  # + 1 GeoJSON

            # iterate through each catLayers type
            for category, layers in catLayers.items():
                # print(f'cat: {category}, layers: {layers}')
                for layer in layers:
                    if opts['quickExport'] and not layer.isModified():
                        continue
                    # todo?: precision as ui param?
                    exporter = QgsJsonExporter(layer, precision=6)
                    exporter.setTransformGeometries(False)  # transforms to EPSG:4326 by default
                    exporter.setVectorLayer(layer)

                    unwanted = ('fid',)
                    fields = [f.name() for f in layer.fields() if f.name() not in unwanted]
                    # print(f'fields: {fields}')

                    # feed all features or only features in the edit buffer here
                    if opts['quickExport']:
                        # theres also .editBuffer().changedAttributeValues() and .editBuffer().changedGeometries()
                        if layer.isEditable():
                            fids = layer.editBuffer().allAddedOrEditedFeatures()
                            features = (layer.getFeature(fid) for fid in fids)
                            if fids and not _export_unsaved_layers: _export_unsaved_layers = True
                        else:
                            # print(f'Quick Export: Skipping layer {layer.name()}')
                            continue
                    else:
                        features = layer.getFeatures()
                    for f in features:
                        # --- GeoJSON feature ---
                        geom: QgsGeometry = f.geometry()
                        if not geom.isEmpty():
                            # todo: add selectExportCrs to top of method
                            if opts['coordinateTransform']:
                                exporter.setTransformGeometries(True)
                                exporter.setDestinationCrs(opts['targetCrs'])

                            # todo: refactor
                            gj_feature = exporter.exportFeature(f)  # returns dict-like JSON
                            gj_obj = json.loads(gj_feature)  # for removing unwanted fields like fid
                            # print(gj_obj['properties'].items())
                            # only keep identifier, category and shortDescription.xx properties
                            wanted = ('identifier', 'category', 'shortDescription')
                            filtered = {'properties': {}}
                            sd = {'shortDescription': {}}  # split shortDescription.xx into nested properties
                            # print(gj_obj['properties'])
                            for k,v in gj_obj['properties'].items():
                                # filters out shortDescriptionAddendum
                                if any(k==w or k.startswith(w + '.') for w in wanted):
                                    if k.startswith('shortDescription.'):
                                        lang = k.split('.')[-1]
                                        sd['shortDescription'][lang] = v
                                    else:
                                        # filtered['properties'] = {k: gj_obj['properties'][k]}
                                        filtered['properties'][k] = v
                            gj_obj['properties'] = filtered['properties']
                            sd_inner = sd.get('shortDescription')
                            if sd_inner: gj_obj['properties']['shortDescription'] = sd_inner
                            # add category property from layer name
                            gj_obj['properties']['category'] = category
                            gj_exp_geoms['features'].append(gj_obj)

                        # --- CSV row ---
                        # row = {field: f[field] for field in fields}
                        row = {}
                        for field_name in fields:
                            val = f[field_name]
                            idx = layer.fields().indexFromName(field_name)
                            setup = layer.editorWidgetSetup(idx)

                            if setup and setup.type() == 'ValueRelation':
                                # config = setup.config()
                                val = self.normalize_export_value(val)
                            row[field_name] = val

                        csv_exp_rows[category].append(row)
                    # print(csv_exp_rows[category])

                    if opts['commitSave']:
                        if layer.isEditable():
                            if not layer.commitChanges():
                                errors = "; ".join(layer.commitErrors())
                                self.mB.pushWarning(self.plugin_name, self.tr('Could not save layer {layer}: {errors}').format(layer=layer.name(), errors=errors))

            if opts['quickExport'] and not _export_unsaved_layers:
                self.mB.pushInfo(self.plugin_name, self.labels['INFO_QUICK_EXPORT_NO_UNSAVED_LAYERS'])
                self.sB.showMessage(self.labels['INFO_QUICK_EXPORT_NO_UNSAVED_LAYERS'], 10000)
            else:
                # upload csv here, after all data has been collected
                headers = {'Content-Type': 'text/csv; charset=utf-8'}
                for i, (cat, rows) in enumerate(csv_exp_rows.items(), start=1):
                    if not rows: continue
                    self.progressBar.setValue(i)
                    self.progressBar.setFormat(self.tr('Exporting category {cat} %p%').format(cat=cat))
                    QApplication.processEvents()

                    seen = set()
                    fieldnames = [k for row in rows for k in row.keys() if not (k in seen or seen.add(k))]
                    # print(f'fieldnames: {fieldnames}')

                    csv_buffer = io.StringIO()
                    writer = csv.DictWriter(csv_buffer, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(rows)

                    csv_content = csv_buffer.getvalue()  # POST data
                    csv_buffer.close()

                    params['category'] = cat
                    data = csv_content.encode('utf-8')
                    params['merge'] = 'false'
                    # print(f'Exporting {cat} as csv with merge=false...')
                    csvResp = \
                    self.api.post('/import/csv', params=params, headers=headers, data=data)
                    params['merge'] = 'true'
                    # print(f'Exporting {cat} as csv with merge=true...')
                    csvRespMerge = \
                    self.api.post('/import/csv', params=params, headers=headers, data=data)
                    QApplication.processEvents()
                    if not all([csvResp, csvRespMerge]): _export_errors = True

                self.progressBar.setValue(total_cats)
                self.progressBar.setFormat(self.tr(f'Exporting GeoJSON %p%'))
                QApplication.processEvents()
                # todo?: always the same params as csv export?
                # upload geojson here
                headers = {'Content-Type': 'application/geo+json'}
                data = json.dumps(gj_exp_geoms)
                params['merge'] = 'false'
                # print('Exporting GeoJSON with merge=false...')
                geoResp = \
                self.api.post('/import/geojson', params=params, headers=headers, data=data)
                params['merge'] = 'true'
                # print('Exporting GeoJSON with merge=true...')
                geoRespMerge = \
                self.api.post('/import/geojson', params=params, headers=headers, data=data)
                self.progressBar.setValue(total_cats + 1)
                QApplication.processEvents()
                # print(csv_exp_rows)
                # print(gj_exp_geoms)
                if not all([geoResp, geoRespMerge]): _export_errors = True

                if _export_errors:
                    self.sB.showMessage(self.labels['EXPORT_ERRORS'], 10000)
                else:
                    self.mB.pushSuccess(self.plugin_name, self.labels['EXPORT_SUCCESS'])
                    self.sB.showMessage(self.labels['EXPORT_SUCCESS'], 10000)
        self._export_running = False
        QTimer.singleShot(2000, self.showOrHideProgressBar)

    # todo: use this in loadImportCategories - old?
    def getCategoryList(self):
        if self.api.isConnectionActive():
            return safe_get(self.api.get(f'/{self.activeProject}/configuration', 3001).json(), 'resource', 'order')
        else: return []

    # todo?: add context parameter?
    def getCategoryCsv(self, cat, cRelations=True):
        csv_opts = f'&schemaOnly=false&context=project&separator=,&combineHierarchicalRelations={str(cRelations).lower()}'
        rCsv = self.api.get(f'/export/csv?category={cat}{csv_opts}')
        rCsv.encoding = 'utf-8'

        return csv.DictReader(io.StringIO(rCsv.text))

    def fieldDisconnect(self):
        """
        Disconnects from Field Desktop and disables settings if a request fails
        """
        # disable import form, switch status led to red, hide connection info
        self.setConnectionEnabled(False)
        self.setConnectionStatus()
        self.toggleFieldInfo()

    def setConnectionStatus(self):
        glow = QGraphicsDropShadowEffect(self.labelConnectStatus)
        glow.setBlurRadius(15)
        glow.setOffset(0, 0)
        if self.connected:
            self.labelConnectStatus.setStyleSheet(f"""
                    background-color: green;
                    border-radius: 6px;
                    border: 1px solid #555;
                """)
            glow.setColor(QColor('green'))
        else:
            self.labelConnectStatus.setStyleSheet(f"""
                    background-color: red;
                    border-radius: 6px;
                    border: 1px solid #555;
                """)
            glow.setColor(QColor('red'))

        self.labelConnectStatus.setGraphicsEffect(glow)